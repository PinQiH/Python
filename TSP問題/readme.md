<h1>TSP問題</h1>

<h3>問題描述</h3>
<p>給定「5個」城市，並以以下表格標示每對城市之間的距離，兩城市間皆有道路可通行。求解在只訪問每一座城市一次的情況下，訪問每座城市並回到起始城市的最短迴路，使得訪問效率最佳。</p>
<table>
  <tr>
    <td></td>
    <td>0</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
  </tr>
  
  <tr>
    <td>0</td>
    <td>0</td>
    <td>38</td>
    <td>19</td>
    <td>19</td>
    <td>18</td>
  </tr>
  
  <tr>
    <td>1</td>
    <td>38</td>
    <td>0</td>
    <td>38</td>
    <td>30</td>
    <td>43</td>
  </tr>
  
  <tr>
    <td>2</td>
    <td>19</td>
    <td>38</td>
    <td>0</td>
    <td>43</td>
    <td>40</td>
  </tr>
  
  <tr>
    <td>3</td>
    <td>19</td>
    <td>30</td>
    <td>43</td>
    <td>0</td>
    <td>10</td>
  </tr>
  
  <tr>
    <td>4</td>
    <td>18</td>
    <td>43</td>
    <td>40</td>
    <td>10</td>
    <td>0</td>
  </tr>
</table>

<h3>演算法說明</h3>
<ui>
  <li>模擬退火演算法(Simulated Annealing, SA): <br>
    <p>首先初始化基本參數，決定起始溫度 t_0、終止溫度 t_min、溫度衰退係數、初始解及城市點相對應的距離矩陣（Distance Matrix），於每次降溫過程中，重複 k 次運算以決定該溫度內的最適解。在不改變起始和結尾城市的情況下，每次以交換 2 個城市順序來產生一新路徑，並計算新路徑的總距離，再和原距離相減以得到兩者之間的差異量diff。因TSP本身為最小化問題，如果diff<0則直接替換新解，反之若是>0則以exp(-diff/t)的概率接受其成為最適解；在此 t 是當前溫度，原理為通過在溫度高時較有可能接受差解和溫度低時幾乎不接受差解，從而避免陷入局部最優的情況。每個溫度內需完成 k 次運算，溫度從t_0、降到t_min，方可達到終止條件。</p>
  </li>
  <li>2-opt: <br>
    <p>隨機選擇一條路線（比方說是0->1->2->3->4->0），並假設其是最短路線min；隨機選擇在該路線中不相連兩個節點，將兩個節點之間的路徑翻轉過來獲得新路徑，比方我們隨機選中了1節點和4節點，則新路徑為0->(4->3->2->1)->0，括號內的部分即為被翻轉的路徑;如果新路徑比min路徑短，則設新路徑為最短路徑min，將計數器count置為0，重新選擇兩個不相連的結點，否則將計數器count加1，當count大於等於最大迭代次數時，演算法結束，此時min即為最短路徑。</p>
  </li>
  <li>蟻群演算法: <br>
    <p>根據問題設置螞蟻種群數量AntCount，此處設為100，當每隻螞蟻完成一次周遊後，牠們會在行進的路上釋放信息素，信息素量與解的質量成正比。螞蟻的路徑會根據信息素濃度及兩點之間的距離倒數，採用隨機的局部搜索策略，使得距離較短的路線，其上的信息素量較大，後來的螞蟻選擇該邊的概率也較大，所有螞蟻都搜索完一次就是迭代一次，每迭代一次就對所有的路線做一次信息素更新，原來的螞蟻死掉，新的螞蟻會進行新一輪搜索。注意，同一代的螞蟻互相之間不會受到之前螞蟻留下的信息素濃度的影響，只會受到上一代螞蟻留下的信息素。第一代螞蟻用的信息素是初始值為1，所有城市之間信息素濃度一樣。達到預定的迭代步數，或出現停滯現象（所有螞蟻都選擇同樣的路徑，解不再變化），則算法結束，以當前最優解作為問題的最優解。由於此演算法會計算距離倒數，因此距離矩陣之對角線設為0.1。</p>
  </li>
</ui>

<h3>實驗結果</h3>
<ui>
  <li>此處演算法之迭代次數均設為422次，蟻群演算法初始蟻數則設為100，方便進行實驗結果比較。</li>
  <li>模擬退火演算法(Simulated Annealing, SA): <br>
    ![image](https://user-images.githubusercontent.com/83577156/177463348-9ddece56-d487-4431-9ff2-254d20d0ac48.png)<br>
    ![image](https://user-images.githubusercontent.com/83577156/177463370-7b88f4a5-9497-4164-a843-b049126dd164.png)<br>
  </li>
  <li>2-opt: <br>
    ![image](https://user-images.githubusercontent.com/83577156/177463429-5d1ac749-95ea-472a-bd20-103584727453.png)<br>
    ![image](https://user-images.githubusercontent.com/83577156/177463445-2019a508-9c1a-4779-b68a-5c9ef605e1f1.png)<br>
  </li>
  <li>蟻群演算法: <br>
    ![image](https://user-images.githubusercontent.com/83577156/177463508-7682f997-8266-4c1d-a385-5aa9e2e74f2d.png)<br>
    ![image](https://user-images.githubusercontent.com/83577156/177463519-2df3c2a9-fb68-44db-a2d0-51df7013cb57.png)<br>
    ![image](https://user-images.githubusercontent.com/83577156/177463533-cf06de5f-d064-4936-9ee0-516f100da888.png)<br>
    ![image](https://user-images.githubusercontent.com/83577156/177463563-23c76ce9-4c34-4588-85ed-eba6eba496c5.png)<br>
    ![image](https://user-images.githubusercontent.com/83577156/177463570-c68875f5-85f2-4652-bffc-009de5248af9.png)<br>
  </li>
</ui>

<h3>結論</h3>
<p>在結果當中，我會將演算法結果與傳統窮舉法結果做比較，以確保演算法結果正確無誤。在模擬退火演算法及2-opt演算法的結果圖當中，可以發現整體距離皆呈現下降趨勢，逐漸降至最低距離115，模擬退火演算法迭代次數至250次左右，數據趨近平穩，而2-opt卻在一剛開始就呈現直線下降趨勢，以非常快的速度找到了最低距離組合，這個結果使我非常驚訝，2-opt是我比較少聽到的演算法，可是呈現的效果可以說是最好的。而在蟻群演算法當中，我取了第1次、第200次、第422次迭代，並觀察其中的螞蟻的嘗試路線及總距離，從結果可以得到越是後面的迭代越會得到較平穩的結果，除此之外，我也畫了每次迭代的最短路徑距離圖，可以發現在第1次迭代的100隻螞蟻內，就有螞蟻成功找出最短路徑，也因此我認為以這三個演算法來比較的話，蟻群演算法的效果最好。(經過消化和思考後，得知蟻群演算法會在最初就找到最佳解的原因為城市只設了5座，其中的排列組合與初始蟻數100相差過少，使得找到最短路徑的速度大大提升，因此可以發現蟻群演算法其實更適用於更大量的計算)</p>
